---
layout:     post
title:      Redis数据结构之简单动态字符串SDS
subtitle:   机会只留给那些准备充分的人
date:       2020-3-31
author:     irving.gx
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - Redis
---


## 初见

之前看过黄健宏老师在2014年写的一本《redis设计与实现（第二版）》，作者开篇就介绍了redis几个基本的数据结构，简单动态字符串（SDS），链表，字典，整数集合等等。当时作者在书中对于SDS的结构介绍是这样的：

 ![image](https://raw.githubusercontent.com/GuoXinsayhello/GuoXinsayhello.github.io/master/img/sds1.jpg)

从官网上下载了最新版本的源码来看，发现SDS最新的数据结构已经不是书中的样子了，现在的SDS的结构是这样的

 ![image](https://raw.githubusercontent.com/GuoXinsayhello/GuoXinsayhello.github.io/master/img/sds2.jpg)
 
了解了一下原因，发现上述的书籍在出版的时候用的是redis 3.0的版本，而目前最新的版本已经到了5.0，redis在3.2版本之后对于redis的结构设计做了较大的改动。因此就最新的redis源码做一下简单的分析。

通过上面两张图的对比可以看到，最新的redis源码对于SDS的数据结构做了较大的调整，从之前统一的一个struct结构体变成了现在的5种不同的数据结构。根据这5种数据结构的名称可以猜测是为了给不同长度的字符串采用不同的数据结构，继续看一下代码来验证我们的猜测对不对。在src/sds.c文件中有这样一个方法

 ![image](https://raw.githubusercontent.com/GuoXinsayhello/GuoXinsayhello.github.io/master/img/sds3.jpg)

可以看到我们的猜想是正确的，SDS会根据字符串的长度决定采用哪种数据类型。这个方法的传入参数的类型是size_t,size_t的全称应该是size_type,就是说一种用来记录大小的数据类型，size_t的真实类型与操作系统有关，在32位架构中被普遍定义为：

```
        typedef unsigned int size_t;
```
而在64位架构中被定义为：
```
        typedef unsigned long size_t;

```

回到图2，我们看一下每个方法中都有__attribute__ ((__packed__))，那这个是什么意思呢？似乎是设置一个attribute（属性），把这个属性设置为packed，这个属性设置的含义是告诉编译器取消内存对齐优化，按照实际占用的字节数进行对齐，那什么是内存对齐优化呢？先看一下数据对齐的规则：

>  1.对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数。

>  2.在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragram pack 指定的数值和结构最大数据成员长度中这两者之中比较小的那个,也就是min(#pragram pack(),长度最长的数据成员，其中#pragram pack(n)表示的是设置n字节对齐，vc6默认的是8。

让我们看下下面一个例子：

 ![image](https://raw.githubusercontent.com/GuoXinsayhello/GuoXinsayhello.github.io/master/img/sds4.jpg)
 
   两个结构体A和B，每个结构体的成员都是一个char类型的，一个int类型的，一个short类型的，但是我们看到这两个结构体的大小却不一样，先看struct A。先是一个1字节的char类型，offset为0，接下来是4字节的int类型，这个int类型的偏移量至少是min(4,8)=4,所以应该在char后面加上三个字节，不存放任何东西，short 占两个字节，min(8,2)=2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为  1xxx|1111|11。在完成第一个规则的对齐之后,还有结构体本身的对齐， min(8,4)=4，所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 1xxx|1111|11xx，一共占据了12个字节。根据上面的陈述可以推出B会占据8个字节。
   
   内存对齐优化的一个好处就是可以提高CPU访问内存的速度，那么redis中设置了__attribute__ ((__packed__))这个属性之后是不是为了节省内存而放弃了CPU的访问速度呢？当然不是。在src/zmalloc.c中redis自己在C语言的基础上自己封装了malloc分配内存的方法，其中有这样的一句，
  
  ```
      if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); 

  ```
  这个语句的含义是先判断当前要分配的_n个内存是否是long类型的整数倍，如果不是就在_n的基础上加上内存大小差值，从而达到了内存对齐的保证。
  
  我们继续回过头看图3中SDS的数据结构，其中len记录了当前字节数组的长度，这样如果要获取一个字符串的长度的话，时间复杂度从O(n)变成了O(1).
  
  > alloc记录了当前字节数组分配的内存大小，这个与len的区别是len是字符串的长度，而alloc是实际分配内存的大小，当字符串大小小于1M的时候会申请两倍的大小，当字符串长度大于等于1M的时候会多分配1M备用。
  
  > flags区分了当前字符串的属性，是属于SDS_TYPE_16还是SDS_TYPE_32等等。目前只用了低3位，高5位暂时没有使用。
  
  > buf是实际存放内容的数组，和传统字符串一样，是以`\0`结尾。
  
  
  - - -
  <p align="center">如果对你有帮助，请作者喝一杯牛奶吧</p>
     
 ![image](https://raw.githubusercontent.com/GuoXinsayhello/GuoXinsayhello.github.io/master/img/wepay.jpg)
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  



        
  
  
  


 
 





